// -*-c++-*-

#include "config.h"
#include "okrfn-int.h"
#include "pubutil.h"
#include "pescape.h"
#include "okcgi.h"
#include "crypt.h"
#include "wide_str.h"
#include "okws_rxx.h"
#include "sfs_assert.h"

#ifdef HAVE_PARSE_PRINTF_FORMAT
extern "C" {
#include <printf.h>
}

namespace {
  // Check that a given string can be used as a format specifier for a printf
  // like function.
  int get_fmt1(const str fmt) {
    int res;
    if (!fmt) {
      return PA_LAST;
    }
    const size_t len = parse_printf_format(fmt.cstr(), 1, &res);
    if (len != 1)
      return PA_LAST;
    return res;
  }
} // namespace
#endif //  HAVE_PARSE_PRINTF_FORMAT

namespace rfn3 {

  // Allocates an `str` with the return value from `sprintf`. We are not using
  // vuio_printf because we have no way to properly validate its input.
  static str stprintf(const char *fmt, ...) {
    int n;
    constexpr size_t BUFFSIZ = 10;
    char buff[BUFFSIZ];
    va_list ap;

    // First try with a stack allocated buffer.
    va_start(ap, fmt);
    n = vsnprintf(buff, BUFFSIZ, fmt, ap);
    va_end(ap);

    // Failure
    if (n < 0) {
      DASSERT(false);
      return nullptr;
    }

    // The stack allocated buff was small enough...
    if (n < BUFFSIZ) {
      return str(buff, n);
    }

    // Now we know the exact size....
    mstr res(n);

    va_start(ap, fmt);
    n = vsnprintf(res.cstr(), res.len() + 1, fmt, ap);
    va_end(ap);

    DASSERT(res.len() == n);

    return str(res);
  }

  //------------------------------------------------------------

  static str
  my_toupper (const str &in)
  {
    if (!in) return in;
    
    mstr out (in.len ());
    for (size_t i = 0; i < in.len (); i++) {
      out[i] = toupper (in[i]);
    }
    out.setlen (in.len ());
    return out;
  }

  //------------------------------------------------------------

  str toupper_t::filter (str s) { return my_toupper (s); }
  str tolower_t::filter (str s) { return my_tolower (s); }
  str html_escape_t::filter (str s) { return xss_escape (s); }
  str hidden_escape_t::filter (str s) { return htmlspecialchars (s); }
  str url_escape_t::filter (str s) { return cgi_encode (s); }
  str url_unescape_t::filter (str s) { return cgi_decode (s);  }
  str utf8_fix_t::filter (str s) { return utf8_fix (s); }
  str wss_filter_t::filter (str s) { return html_wss (s); }

  //------------------------------------------------------------

  const str toupper_t::DOCUMENTATION = R"*(Convert all alpha characters in `s` to
uppercase

@param {string} s
@return {string})*";

  const str tolower_t::DOCUMENTATION = R"*(Convert all alpha characters in `s` to
lowercase

@param {string} s
@return {string})*";

  const str html_escape_t::DOCUMENTATION = R"*(HTML escapes these chars: `&` `<`
`>`

@param {string} s
@return {string})*";

  const str url_escape_t::DOCUMENTATION = R"*(Produce a URL-encoded version of
the string `s`

@param {string} s
@return {string})*";

  const str url_unescape_t::DOCUMENTATION = R"*(Take a URL-escaped string `s` and
return the unescaping of it.

@param {string} s
@return {string})*";

  const str utf8_fix_t::DOCUMENTATION = R"*(Strips out any malformed UTF-8
characters from `s`.

@param {string} s
@return {string})*";

  const str hidden_escape_t::DOCUMENTATION =
    "HTML escapes these chars: `'` `\"` `&` `<` `>`\n"
    "\n"
    "@param {string} s\n"
    "@return {string}";

  const str wss_filter_t::DOCUMENTATION = R"*(compacts multiple adjacent
whitespace characters into one

@param {string} s
@return {string})*";

  //------------------------------------------------------------

  ptr<const expr_t>
  tag_escape_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    ptr<rxx> r;

    if (args.size () >= 2) {
      r = args[1]._r;
    } else { 
      static ptr<rxx> dflt_rxx;
      if (!(r = dflt_rxx)) {
	str x = "<[/\\s]*(b|br|i|p)[/\\s]*>";
	str err;
	r = pub3::rxx_factory_t::compile (x, "i", &err);
	if (!r) {
	  report_error (p, err);
	} else {
	  dflt_rxx = r;
	}
      }
    }

    str s;
    if (r) {
      html_filter_rxx_t filt (r);
      str in = args[0]._s;
      s = filt.run (in);
    }
    return expr_str_t::safe_alloc (s);
  }

  //------------------------------------------------------------

  const str tag_escape_t::DOCUMENTATION = R"*(Escape all tags except for `<b>`,
`<i>`, `<br>` and `<p>`.

@param {string} s
@return {string})*";

  //------------------------------------------------------------

  ptr<const expr_t>
  substr_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    str s = args[0]._s;
    size_t start = 0, len = 0;
    start = args[1]._i;
    size_t slen = utf8_len (s);

    if (args.size () >= 3) { len = args[2]._i; }
    else { len = slen; }

    if (start >= slen) { start = slen; }
    if (start + len >= slen) { len = slen - start; }

    str r = utf8_substr (s, start, len);
    return expr_str_t::safe_alloc (r);
  }

  //------------------------------------------------------------

  const str substr_t::DOCUMENTATION = R"*(Output a substring of `s`, starting at
character `start` and `len` bytes long.

@param {string} s
@param {int} start
@optional
@param {int} len
@return {string})*";

  //------------------------------------------------------------

  bool
  default_t::count_args (eval_t *p, size_t sz) const
  {
    bool ret = true;
    if (sz < 1 || sz > 2) {
      report_error (p, "default() expects 1 or 2 args");
      ret = false;
    }
    return ret;
  }

  //------------------------------------------------------------

  ptr<const expr_t>
  default_t::eval_to_val (eval_t *p, args_t args) const
  {
    ptr<const expr_t> ret, def;
    bool is_null;

    if (count_args (p, args->size ())) {
     
      is_null = (*args)[0] ? (*args)[0]->eval_as_null (p) : true;
      
      if (args->size () > 1) { def = (*args)[1]->eval_to_val (p); } 
      else { def = expr_str_t::alloc (""); }
      
      ret = is_null ? def : (*args)[0]->eval_to_val (p);
    }
    return ret;
  }

  //------------------------------------------------------------

  tamed void
  default_t::pub_to_val (eval_t *p, callable_t::args_t args, cxev_t ev) const
  {
    tvars {
      ptr<const expr_t> ret, def;
      bool is_null;
    }

    if (count_args (p, args->size ())) {
      if (!(*args)[0]) { 
	is_null = true; 
      } else { 
	twait { (*args)[0]->pub_as_null (p, mkevent (is_null)); } 
      }

      if (args->size () > 1) { 
	twait { (*args)[1]->pub_to_val (p, mkevent (def)); }
      } else { 
	def =  expr_str_t::alloc ("");
      }

      if (is_null) { 
	ret = def; 
      } else { 
	twait { (*args)[0]->pub_to_val (p, mkevent (ret)); }
      }
    }
    ev->trigger (ret);
  }

  //------------------------------------------------------------

  const str default_t::DOCUMENTATION = R"*(Given the input value `in`, check to
see if it's `null`.  If `null`, then output `val`, outherwise, output `in`.
If `val` wasn't specified and `in` is null, then output the empty string
@brief output a default fallback value when `in` is `null`
@param {object} in
@optional
@param {object} val
@return {object}
@example
{% locals { d : { x : "hi" } } %}
%{d.y|default("bye")} // will output "bye"
%{d.z|default} // will output "" and will not produce any warnings.
@response)*";

  //------------------------------------------------------------

  static bool
  is_empty (const char *s)
  {
    for (const char *cp = s; *cp; cp++) {
      if (!isspace (*cp)) return false;
    }
    return true;
  }

  //------------------------------------------------------------

  str strip_t::filter (str s)
  {
    static rxx x ("\\s+");
    vec<str> v;
    split (&v, x, s);
    strbuf b;
    bool output = false;
    for (size_t i = 0; i < v.size (); i++) {
      if (!is_empty (v[i].cstr())) {
	if (output) { b << " "; }
	b << v[i];
	output = true;
      }
    }
    return b;
  }

  //------------------------------------------------------------

  const str strip_t::DOCUMENTATION = R"*(Strips leading, trailing spaces and
reduce in-between spaces to just one space

@param {string} s
@return {string})*";

  //------------------------------------------------------------

  str sha1_t::filter (str s) 
  {
    char buf[sha1::hashsize];
    sha1_hash (buf, s.cstr (), s.len ());
    strbuf b;
    b << hexdump (buf, sha1::hashsize);
    return b;
  }

  //------------------------------------------------------------

  const str sha1_t::DOCUMENTATION = R"*(Produce the SHA-1 hash of `s`, outputting
a hexidecimal-encoded digest.

@param {string} s
@return {string})*";

  //------------------------------------------------------------

  ptr<const expr_t>
  format_float_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    str fmt = args[0]._s;
    int spec = PA_FLOAT;
    str res;
#ifdef HAVE_PARSE_PRINTF_FORMAT
    spec = get_fmt1(fmt);
#endif
    if (spec == PA_FLOAT) {
      float f = args[1]._f;
      res = stprintf(fmt.cstr (), f);
    } else if (spec == (PA_DOUBLE)) {
      double d = args[1]._f;
      res = stprintf(fmt.cstr (), d);
    } else if (spec == (PA_DOUBLE | PA_FLAG_LONG_DOUBLE)) {
      long double ld = args[1]._f;
      res = stprintf (fmt.cstr (), ld);
    }  else {
      report_error(p, strbuf("Not a float format \"%s\" %i", fmt.cstr(), spec));
      return expr_null_t::alloc();
    }
    return expr_str_t::alloc(res);
  }

  //------------------------------------------------------------

  const str format_float_t::DOCUMENTATION = R"*(Format the float `val` according
to the given sprintf-style format string `fmt`.

@param {string} fmt
@param {float} val
@return {string})*";

  //------------------------------------------------------------

  ptr<const expr_t>
  format_int_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    str fmt = args[0]._s;
    str res;
    int spec = PA_INT;
    #ifdef HAVE_PARSE_PRINTF_FORMAT
    spec = get_fmt1(fmt);
    #endif
    if (spec == PA_INT) {
      int i = args[1]._i;
      res = stprintf (fmt.cstr (), i);
    } else if (spec == PA_CHAR) {
      char c = args[1]._i;
      res = stprintf (fmt.cstr (), c);
    } else if (spec == (PA_INT | PA_FLAG_SHORT)) {
      short s = args[1]._i;
      res = stprintf (fmt.cstr (), s);
    } else if (spec == (PA_INT | PA_FLAG_LONG)) {
      long l = args[1]._i;
      res = stprintf (fmt.cstr (), l);
    } else if (spec == (PA_INT | PA_FLAG_LONG_LONG)) {
      long long ll = args[1]._i;
      res = stprintf (fmt.cstr (), ll);
    }  else {
      report_error(p, strbuf("Not an int format \"%s\" %i", fmt.cstr(), spec));
      return expr_null_t::alloc();
    }
    return expr_str_t::alloc (res);
  }

  //------------------------------------------------------------

  const str format_int_t::DOCUMENTATION = R"*(Format the int `val` according to
the given sprintf-style format string `fmt`.

@param {string} fmt
@param {int} val
@return {string})*";

  //------------------------------------------------------------

  ptr<const expr_t>
  format_uint_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    str res;
    str fmt = args[0]._s;
    int spec = PA_INT;
    #ifdef HAVE_PARSE_PRINTF_FORMAT
    spec = get_fmt1(fmt);
    #endif
    if (spec == PA_INT) {
      unsigned int i = args[1]._u;
      res = stprintf (fmt.cstr (), i);
    } else if (spec == PA_CHAR) {
      unsigned char c = args[1]._u;
      res = stprintf (fmt.cstr (), c);
    } else if (spec == (PA_INT | PA_FLAG_SHORT)) {
      unsigned short s = args[1]._u;
      res = stprintf (fmt.cstr (), s);
    } else if (spec == (PA_INT | PA_FLAG_LONG)) {
      unsigned long l = args[1]._u;
      res = stprintf (fmt.cstr (), l);
    } else if (spec == (PA_INT | PA_FLAG_LONG_LONG)) {
      unsigned long long ll = args[1]._u;
      res = stprintf (fmt.cstr (), ll);
    }  else {
      report_error(p, strbuf("Not an int format \"%s\" %i", fmt.cstr(), spec));
      return expr_null_t::alloc();
    }
    return expr_str_t::alloc (res);
  }

  //------------------------------------------------------------

  const str format_uint_t::DOCUMENTATION = R"*(Format the uint `val` according
to the given sprintf-style format string `fmt`.

@param {string} fmt
@param {uint} val
@return {string})*";

  //------------------------------------------------------------

  ptr<const expr_t>
  json_escape_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    str s = args[0]._s;
    str ret = json_escape (s, true, p->utf8_json ());
    return expr_str_t::alloc (ret);
  }

  //------------------------------------------------------------

  const str json_escape_t::DOCUMENTATION = R"*(Escapes all double-quotes,
backslashes, newlines and tabs.

@param {string} s
@return {string})*";

  ptr<const expr_t>
  js_escape_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    str s = args[0]._s;
    str ret = json_escape (s, true, p->utf8_json ());
    ret = rxx_replace_2(ret, "</", "<\\/");
    ret = rxx_replace_2(ret, "'", "\\'");
    return expr_str_t::alloc (ret);
  }

  //------------------------------------------------------------

  const str js_escape_t::DOCUMENTATION = R"*(First runs `json_escape`, then
replaces `<` with `<\/`.

@param {string} s
@return {string})*";

  //------------------------------------------------------------

  ptr<const expr_t>
  index_of_t::v_eval_2 (eval_t *p, const vec<arg_t> &args) const
  {
    str big_s = args[0]._s;
    str small_s = args[1]._s;
    size_t start = 0;
    if (args.size () == 3) { start = args[2]._i; }
    int ret = -1;
    if (start < big_s.len ()) {
      const char *big = big_s + start;
      const char *small = small_s.cstr();
      const char *pos = strstr (big, small);
      if (pos) { ret = (pos - big) + start; }
    }
    return expr_int_t::alloc (ret);
  }

  const str index_of_t::DOCUMENTATION = R"*(Finds the index of the first
occurrence of `pat` in `body`.

Optionally, provide an index to `start` the search from
@param {string} body
@param {string} pat
@optional
@param {int} start
@return {int}
@example index_of('ABCABC', 'B')
@example index_of('ABCABC', 'B', 2))*";
  //------------------------------------------------------------

};
